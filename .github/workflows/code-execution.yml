name: Code Execution Workflow
on:
  workflow_dispatch:
    inputs:
      language:
        description: 'Programming language (cpp, python, java)'
        required: true
      code:
        description: 'Source code to execute'
        required: true
      input:
        description: 'Input for the program'
        required: false
        default: ''
      expected:
        description: 'Expected output for comparison'
        required: false
        default: ''

jobs:
  execute-code:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      
      - name: Setup execution environment
        run: |
          # Setup based on language
          if [ "${{ github.event.inputs.language }}" == "cpp" ]; then
            sudo apt-get update && sudo apt-get install -y g++
          elif [ "${{ github.event.inputs.language }}" == "java" ]; then
            sudo apt-get update && sudo apt-get install -y openjdk-17-jdk
          elif [ "${{ github.event.inputs.language }}" == "python" ]; then
            sudo apt-get update && sudo apt-get install -y python3
          fi
      
      - name: Create files
        run: |
          echo '${{ github.event.inputs.code }}' > source.${{ github.event.inputs.language }}
          echo '${{ github.event.inputs.input }}' > input.txt
      
      - name: Compile and run
        id: execute
        continue-on-error: true
        timeout-minutes: 2
        run: |
          start_time=$(date +%s%N)
          status="AC"
          error_msg=""
          
          if [ "${{ github.event.inputs.language }}" == "cpp" ]; then
            g++ -o program source.cpp 2> compile_error.txt
            if [ $? -ne 0 ]; then
              status="CE"
              error_msg=$(cat compile_error.txt)
            else
              /usr/bin/time -f "%M" -o memory.txt ./program < input.txt > output.txt 2> runtime_error.txt
              if [ $? -ne 0 ]; then
                status="RE"
                error_msg=$(cat runtime_error.txt)
              fi
            fi
          # Similar blocks for Java and Python
          fi
          
          end_time=$(date +%s%N)
          execution_time=$((($end_time - $start_time)/1000000))
          
          # Check time limit
          if [ $execution_time -gt 2000 ] && [ "$status" == "AC" ]; then
            status="TLE"
          fi
          
          # Check memory limit if available
          if [ -f memory.txt ] && [ "$status" == "AC" ]; then
            memory=$(cat memory.txt)
            if [ $memory -gt 512000 ]; then
              status="MLE"
            fi
          fi
          
          # Check if output matches expected
          if [ "$status" == "AC" ]; then
            if [ "${{ github.event.inputs.expected }}" != "" ]; then
              if ! diff -w output.txt <(echo '${{ github.event.inputs.expected }}') > /dev/null; then
                status="WA"
              fi
            fi
          fi
          
          echo "STATUS=$status" >> $GITHUB_OUTPUT
          echo "EXECUTION_TIME=$execution_time" >> $GITHUB_OUTPUT
          if [ -f output.txt ]; then
            output=$(cat output.txt)
            echo "OUTPUT<<EOF" >> $GITHUB_OUTPUT
            echo "$output" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          if [ -n "$error_msg" ]; then
            echo "ERROR_MSG<<EOF" >> $GITHUB_OUTPUT
            echo "$error_msg" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
      
      - name: Set result
        run: |
          echo "::set-output name=result::${{ steps.execute.outputs.STATUS }}"
          echo "::set-output name=output::${{ steps.execute.outputs.OUTPUT }}"
          echo "::set-output name=error::${{ steps.execute.outputs.ERROR_MSG }}"
          echo "::set-output name=execution_time::${{ steps.execute.outputs.EXECUTION_TIME }}"